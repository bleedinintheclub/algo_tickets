## 6. Сортировка подсчетом  

**Сортировка подсчётом (Counting Sort)** — это не основанная на сравнении элементов сортировка,  
работающая за **O(n + k)**, где `n` — количество элементов, а `k` — диапазон возможных значений.

### Идея алгоритма

Если известно, что элементы массива — это **целые числа из ограниченного диапазона**,  
можно просто посчитать, сколько раз встречается каждое значение, а затем восстановить массив в отсортированном виде.

_Устойчивость_ сортировки зависит от реализации.
### Пример

Пусть массив:

`[4, 2, 2, 8, 3, 3, 1]`

Подсчёт количества вхождений:

`Значение:     1  2  3  4  5  6  7  8`
`Количество:   1  2  2  1  0  0  0  1`

Восстановление массива по счётчикам:

`[1, 2, 2, 3, 3, 4, 8]`

### Реализация

для чисел в диапазоне 100 (неустойчивая):
```cpp
void count_sort(int* arr, int size) {
    int* count_arr = new int[100]();  // важно инициализировать нулями

    // Подсчёт количества вхождений каждого числа
    for (int i = 0; i < size; i++) {
        count_arr[arr[i] - 1]++;      // -1, т.к. индексация с 0
    }

    int k = 0;

    // Восстановление отсортированного массива
    for (int i = 0; i < 100; i++) {
        while (count_arr[i]-- > 0) {
            arr[k++] = i + 1;         // +1, чтобы вернуть исходное значение
        }
    }

    delete[] count_arr;
}
```

устойчивая реализация через префиксные суммы:
```cpp
void count_sort(int* arr, int n, int max_val) {
    // Создаём вспомогательные массивы
    int* count = new int[max_val + 1]{0}; // массив частот
    int* output = new int[n];              // результирующий массив (для устойчивости)

    // Подсчитываем количество вхождений каждого значения
    for (int i = 0; i < n; i++)
        count[arr[i]]++;

    // Преобразуем count[] в префиксные суммы
    // Теперь count[i] хранит индекс последнего элемента со значением i
    for (int i = 1; i <= max_val; i++)
        count[i] += count[i - 1];

    // Формируем выходной массив (справа налево — для устойчивости)
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;  // уменьшаем индекс для следующего такого же значения
    }

    // Копируем результат обратно в arr[]
    for (int i = 0; i < n; i++)
        arr[i] = output[i];

    delete[] count;
    delete[] output;
}
```

#### Устойчивая реализация с отрицательными числами
Алгоритм работы:
- Находим диапазон значений в массиве (min_val и max_val)

- Создаем массив счетчиков с учетом сдвига для отрицательных чисел

- Строим префиксные суммы для определения позиций элементов

- Формируем результат справа налево для сохранения устойчивости

```cpp
void count_sort(int* arr, int n) {
    if (n == 0) return;
    
    // Находим min и max значения
    int min_val = arr[0], max_val = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] < min_val) min_val = arr[i];
        if (arr[i] > max_val) max_val = arr[i];
    }
    
    int range = max_val - min_val + 1;
    int* count = new int[range]{0};
    int* output = new int[n];
    
    // Подсчёт частот
    for (int i = 0; i < n; i++)
        count[arr[i] - min_val]++;
    
    // Префиксные суммы
    for (int i = 1; i < range; i++)
        count[i] += count[i - 1];
    
    // Устойчивая сортировка
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i] - min_val] - 1] = arr[i];
        count[arr[i] - min_val]--;
    }
    
    // Копирование обратно
    for (int i = 0; i < n; i++)
        arr[i] = output[i];
    
    delete[] count;
    delete[] output;
}
```


#### Пояснение работы

1. **Создаётся вспомогательный массив `count_arr`** длиной `k` (здесь 100).  
    В `count_arr[i]` хранится количество элементов, равных `i+1`.
    
2. **Заполняем `count_arr`**:  
    Проходим по всем элементам исходного массива и увеличиваем соответствующий счётчик.
    
3. **Формируем результат**:  
    Проходим по `count_arr`, и для каждого числа, встречающегося `count_arr[i]` раз,  
    записываем это число в итоговый массив.

### Временная сложность

Сортировка подсчётом проходит два этапа:

1. **Подсчёт элементов** — один проход по массиву `O(n)`
2. **Восстановление отсортированного массива** — проход по диапазону значений `O(k)`
    
Таким образом: `O(n + k)`
где
- `n` — число элементов,
- `k` — размер диапазона возможных значений.
    
Если `k` ограничено константой (например, числа от 1 до 100), то алгоритм работает **за линейное время O(n)**.  
Если же диапазон очень велик (`k >> n`), эффективность падает.

### Пространственная сложность

Сортировка использует дополнительный массив счётчиков размером `k`.
Таким образом: `O(k)` 
Counting Sort выгоден **только при сравнительно малом диапазоне значений**.

